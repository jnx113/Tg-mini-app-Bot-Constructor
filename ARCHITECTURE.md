# Обзор архитектуры программного продукта

## 1. Общая архитектура

Программный продукт представляет собой **full-stack веб-приложение** для создания и управления Telegram-ботами через визуальный редактор сценариев. Система состоит из двух основных частей:

1. **Frontend** - одностраничное веб-приложение (SPA) на React
2. **Backend** - RESTful API сервер для управления ботами и сценариями

### Технологический стек Frontend:

- **Frontend Framework**: React 19.1.1
- **Build Tool**: Vite 7.1.2
- **Routing**: React Router DOM 7.9.6
- **Визуальный редактор**: ReactFlow (@xyflow/react 12.9.3)
- **HTTP-клиент**: Axios 1.13.2
- **Стилизация**: CSS Modules

### Технологический стек Backend (предположительно):

- **API Framework**: Django REST Framework / FastAPI / Express.js
- **База данных**: PostgreSQL / MySQL
- **Аутентификация**: JWT (JSON Web Token)
- **Telegram Integration**: python-telegram-bot / node-telegram-bot-api

## 2. Архитектурные решения

### 2.1. Компонентная архитектура (Component-Based Architecture)

Приложение следует принципам **компонентно-ориентированной архитектуры**, где каждый функциональный блок инкапсулирован в отдельный React-компонент. Это обеспечивает:

- **Переиспользование кода**: Компоненты могут использоваться в разных частях приложения
- **Модульность**: Каждый компонент отвечает за свою функциональность
- **Легкость тестирования**: Компоненты можно тестировать изолированно
- **Поддерживаемость**: Изменения в одном компоненте не влияют на другие

### 2.2. Структура проекта

```
src/
├── components/          # React-компоненты
│   ├── Nodes/          # Компоненты узлов сценария
│   ├── Pop-up_windows/ # Модальные окна
│   └── [Основные компоненты]
├── styles/             # CSS Modules стили
├── assets/             # Статические ресурсы (изображения, иконки)
├── App.jsx             # Корневой компонент с роутингом
└── main.jsx            # Точка входа приложения
```

### 2.3. Маршрутизация (Client-Side Routing)

Приложение использует **React Router** для навигации между страницами без перезагрузки:

- `/dashboard` - Главная страница со списком сценариев
- `/bots` - Страница управления ботами
- `/bot-settings/:id` - Настройки конкретного бота
- `/script-edit` - Визуальный редактор сценариев

**Обоснование**: SPA-подход обеспечивает быструю навигацию и улучшает пользовательский опыт, исключая задержки на перезагрузку страниц.

## 3. Основные компоненты и их связи

### 3.1. Корневой компонент (App.jsx)

**Роль**: Центральный компонент, управляющий маршрутизацией и общей структурой приложения.

**Связи**:

- Оборачивает все маршруты в `<BrowserRouter>`
- Включает `<NavPanel>` на всех страницах
- Использует `<ReactFlowProvider>` для редактора сценариев

**Архитектурный паттерн**: Layout Component Pattern

### 3.2. Навигационная панель (NavPanel.jsx)

**Роль**: Горизонтальная навигация между основными разделами приложения.

**Особенности**:

- Определяет активный маршрут через `useLocation()`
- Визуально выделяет текущую страницу
- Обеспечивает быстрый доступ к основным функциям

**Связи**: Используется в `App.jsx` как глобальный компонент навигации.

### 3.3. Дашборд (Dashboard.jsx)

**Роль**: Главная страница для управления сценариями.

**Функциональность**:

- Отображение списка сценариев (активных и архивных)
- Поиск и фильтрация сценариев
- Создание новых сценариев

**Связи**:

- Использует `ScriptList` для отображения списка
- Переходит на `/script-edit` для создания нового сценария

**Состояние**: Управляет переключением между активными сценариями и архивом через `useState`.

### 3.4. Редактор сценариев (ScriptEdit.jsx)

**Роль**: Визуальный редактор для создания и редактирования сценариев ботов.

**Ключевые особенности**:

- Использует **ReactFlow** для визуализации графа узлов
- Управляет состоянием узлов и связей через `useNodesState` и `useEdgesState`
- Реализует паттерн **Controlled Components** для синхронизации данных

**Архитектурные паттерны**:

1. **State Management Pattern**: Централизованное управление состоянием узлов
2. **Callback Pattern**: Передача `handleNodeChange` в узлы для обновления данных
3. **Factory Pattern**: `generateNodeId` для создания уникальных идентификаторов

**Связи**:

- Использует компоненты узлов из `Nodes/`
- Интегрирует `CreateNode` для добавления новых узлов
- Сохраняет схему в формате для бэкенда (метод `saveFlow`)

**Обработка данных**:

```javascript
// Очистка данных перед отправкой на бэкенд
const cleanNodes = nodes.map((node) => {
  const { onChange: _onChange, ...cleanData } = node.data;
  return { id, type, position, data: cleanData };
});
```

### 3.5. Компоненты узлов (Nodes/)

**Роль**: Специализированные компоненты для различных типов узлов сценария.

**Типы узлов**:

1. **StartNode** - Начальный узел с командами запуска
2. **MessageNode** - Узел отправки сообщений
3. **QuestionTextNode** - Узел текстового ввода
4. **QuestionChoice** - Узел выбора из вариантов
5. **ConditionNode** - Узел условного ветвления
6. **ExitNode** - Конечный узел сценария

**Архитектурные особенности**:

- Каждый узел использует **Handle** из ReactFlow для создания связей
- Реализует паттерн **Lifted State Up**: данные хранятся в родительском компоненте
- Использует `onChange` callback для синхронизации с родителем

**Пример взаимодействия**:

```javascript
// В узле
const onChange = data?.onChange;
onChange?.(id, { commands: cleanedCommands });

// В ScriptEdit
const handleNodeChange = useCallback(
  (nodeId, newData) => {
    setNodes((nds) =>
      nds.map((node) =>
        node.id === nodeId
          ? { ...node, data: { ...node.data, ...newData } }
          : node
      )
    );
  },
  [setNodes]
);
```

### 3.6. Управление ботами (Bots.jsx, BotSettings.jsx)

**Роль**: Компоненты для управления списком ботов и их настройками.

**Функциональность**:

- Получение списка ботов через REST API
- Редактирование параметров бота (имя, описание, контакты)
- Активация/деактивация ботов

**Связи с бэкендом**:

- Использует **Axios** для HTTP-запросов
- API endpoint: `https://minutely-sisterly-smelt.cloudpub.ru/api/v1/bots/`
- Аутентификация через Bearer Token

**Архитектурный паттерн**: Container/Presentational Pattern

- `Bots.jsx` - контейнер (управление состоянием и API)
- `BotList.jsx` - презентационный компонент (отображение)

## 4. Управление состоянием

### 4.1. Локальное состояние (Local State)

Приложение использует **React Hooks** для управления локальным состоянием:

- `useState` - для простого состояния компонентов
- `useEffect` - для побочных эффектов (API-запросы, синхронизация)
- `useCallback` - для мемоизации функций

### 4.2. Состояние ReactFlow

ReactFlow предоставляет собственные хуки:

- `useNodesState` - управление узлами графа
- `useEdgesState` - управление связями между узлами

**Обоснование**: ReactFlow инкапсулирует сложную логику работы с графом, предоставляя простой API для управления узлами и связями.

## 5. Стилизация

### CSS Modules

Приложение использует **CSS Modules** для изоляции стилей:

- Каждый компонент имеет свой модуль стилей
- Импорт: `import styles from "./Component.module.css"`
- Использование: `className={styles.ClassName}`

**Преимущества**:

- Изоляция стилей (нет конфликтов имен)
- Явная связь между компонентом и его стилями
- Поддержка автодополнения в IDE

## 6. Интеграция с бэкендом

### 6.1. REST API

Приложение взаимодействует с REST API через **Axios**:

**Базовый URL**: `https://minutely-sisterly-smelt.cloudpub.ru/api/v1/`

**Аутентификация**:

- Используется **JWT Bearer Token** (JSON Web Token)
- Токен передается в заголовке `Authorization: Bearer <token>`
- Токен хранится в модуле `auth.js` (в продакшене следует использовать безопасное хранилище, например, `localStorage` или `sessionStorage`)

**Типичные операции**:

- `GET /api/v1/bots/` - получение списка ботов
- `GET /api/v1/bots/:id/` - получение данных конкретного бота
- `PUT /api/v1/bots/:id/` - обновление данных бота (статус, имя, описание, контакты)
- `POST /api/save-flow` - сохранение схемы сценария (закомментировано в коде)

**Архитектурный паттерн**: Repository Pattern (неявно через Axios)

### 6.2. Структура данных API

**Модель Bot** (на основе использования в коде):

```typescript
interface Bot {
  id: string; // Уникальный идентификатор бота
  name: string; // Название бота
  description: string; // Описание бота
  contacts: string; // Контактная информация
  status: "active" | "inactive"; // Статус бота
  token: string; // Telegram Bot Token
  // Дополнительные поля (предположительно):
  language?: string; // Язык интерфейса
  timezone?: string; // Часовой пояс
  created_at?: string; // Дата создания
  updated_at?: string; // Дата обновления
}
```

**Модель Flow/Script** (на основе метода `saveFlow`):

```typescript
interface Flow {
  nodes: Node[]; // Массив узлов сценария
  edges: Edge[]; // Массив связей между узлами
}

interface Node {
  id: string; // Уникальный идентификатор узла
  type: string; // Тип узла (start, message, textInput, etc.)
  position: { x: number; y: number }; // Позиция на канвасе
  data: NodeData; // Данные узла (зависят от типа)
}

interface Edge {
  id: string; // Уникальный идентификатор связи
  source: string; // ID исходного узла
  target: string; // ID целевого узла
}
```

## 7. Архитектура бэкенда

### 7.1. Общая архитектура бэкенда

Бэкенд представляет собой **RESTful API сервер**, обеспечивающий управление Telegram-ботами и их сценариями. На основе анализа фронтенда можно предположить следующую архитектуру:

**Предполагаемый технологический стек**:

- **API Framework**: Django REST Framework / FastAPI / Express.js (на основе структуры URL `/api/v1/`)
- **База данных**: PostgreSQL / MySQL (для хранения данных ботов и сценариев)
- **Аутентификация**: JWT (JSON Web Token)
- **Telegram Integration**: python-telegram-bot / node-telegram-bot-api (для взаимодействия с Telegram API)

### 7.2. Архитектурные слои бэкенда

#### 7.2.1. Слой представления (Presentation Layer)

**REST API Endpoints**:

```
/api/v1/
├── bots/
│   ├── GET    /              # Список всех ботов пользователя
│   ├── GET    /:id/          # Получение конкретного бота
│   ├── POST   /              # Создание нового бота
│   ├── PUT    /:id/          # Обновление бота
│   └── DELETE /:id/          # Удаление бота
├── scripts/ (предположительно)
│   ├── GET    /              # Список сценариев
│   ├── GET    /:id/          # Получение сценария
│   ├── POST   /              # Создание сценария
│   ├── PUT    /:id/          # Обновление сценария
│   └── DELETE /:id/          # Удаление сценария
└── auth/ (предположительно)
    ├── POST   /login/        # Авторизация
    ├── POST   /register/     # Регистрация
    └── POST   /refresh/       # Обновление токена
```

**Архитектурный паттерн**: RESTful API Design

#### 7.2.2. Слой бизнес-логики (Business Logic Layer)

**Основные сервисы**:

1. **BotService** - управление ботами

   - Валидация токенов Telegram
   - Активация/деактивация ботов
   - Управление настройками ботов

2. **ScriptService** - управление сценариями

   - Сохранение и загрузка схем сценариев
   - Валидация структуры графа узлов
   - Компиляция сценария в исполняемый формат

3. **TelegramService** - интеграция с Telegram

   - Отправка сообщений через Telegram Bot API
   - Обработка входящих сообщений
   - Управление webhook'ами

4. **AuthService** - аутентификация и авторизация
   - Генерация и валидация JWT токенов
   - Управление сессиями пользователей

**Архитектурный паттерн**: Service Layer Pattern

#### 7.2.3. Слой доступа к данным (Data Access Layer)

**Модели данных**:

1. **User** - пользователи системы
2. **Bot** - боты пользователей
3. **Script** - сценарии ботов
4. **Node** - узлы сценариев
5. **Edge** - связи между узлами

**Архитектурный паттерн**: Repository Pattern / Active Record Pattern

### 7.3. Аутентификация и безопасность

#### 7.3.1. JWT Authentication

**Процесс аутентификации**:

1. Пользователь отправляет credentials (email/password) на `/api/v1/auth/login/`
2. Сервер проверяет credentials и генерирует JWT токен
3. Токен возвращается клиенту
4. Клиент включает токен в заголовок `Authorization: Bearer <token>` для всех последующих запросов
5. Сервер валидирует токен на каждом запросе

**Структура JWT токена** (на основе анализа):

```json
{
  "sub": "865c9852-717e-4195-bfd6-398abc49f941", // User ID
  "exp": 1766667702, // Expiration timestamp
  "iat": 1766664102 // Issued at timestamp
}
```

#### 7.3.2. Безопасность

- **HTTPS**: Все запросы должны выполняться по защищенному протоколу
- **CORS**: Настройка Cross-Origin Resource Sharing для фронтенда
- **Rate Limiting**: Ограничение количества запросов для предотвращения злоупотреблений
- **Input Validation**: Валидация всех входящих данных
- **SQL Injection Protection**: Использование параметризованных запросов

### 7.4. Интеграция с Telegram

#### 7.4.1. Telegram Bot API

Бэкенд взаимодействует с **Telegram Bot API** для:

- Регистрации webhook'ов для получения обновлений
- Отправки сообщений пользователям
- Обработки команд и callback'ов от кнопок
- Управления клавиатурами (inline и reply)

#### 7.4.2. Обработка сценариев

**Процесс выполнения сценария**:

1. Пользователь отправляет команду боту (например, `/start`)
2. Бэкенд получает обновление через webhook
3. Система определяет соответствующий сценарий и начальный узел
4. Выполняется логика узла (отправка сообщения, обработка ответа)
5. На основе ответа пользователя определяется следующий узел
6. Процесс повторяется до достижения конечного узла

**Архитектурный паттерн**: State Machine Pattern

### 7.5. Хранение данных

#### 7.5.1. База данных

**Предполагаемая схема БД**:

```sql
-- Пользователи
Users (id, email, password_hash, created_at, updated_at)

-- Боты
Bots (id, user_id, name, description, token, status, created_at, updated_at)

-- Сценарии
Scripts (id, bot_id, name, status, created_at, updated_at)

-- Узлы сценариев
Nodes (id, script_id, type, position_x, position_y, data_json)

-- Связи между узлами
Edges (id, script_id, source_node_id, target_node_id)
```

#### 7.5.2. Формат хранения сценариев

Сценарии хранятся в виде **графа узлов и связей**:

- **Nodes** хранят тип узла, позицию и данные (JSON)
- **Edges** хранят связи между узлами
- Данные узлов сериализуются в JSON для гибкости

**Преимущества**:

- Гибкость: легко добавлять новые типы узлов
- Визуализация: структура соответствует визуальному редактору
- Версионирование: можно хранить историю изменений

### 7.6. Обоснование архитектурных решений бэкенда

#### 7.6.1. RESTful API

**Преимущества**:

- Стандартизация: широко используемый подход
- Кэширование: поддержка HTTP кэширования
- Масштабируемость: легко добавлять новые endpoints
- Совместимость: работает с любым клиентом

#### 7.6.2. JWT Authentication

**Преимущества**:

- Stateless: не требует хранения сессий на сервере
- Масштабируемость: легко масштабировать на несколько серверов
- Безопасность: токены подписываются и могут быть зашифрованы
- Мобильность: легко использовать в мобильных приложениях

#### 7.6.3. Графовая структура сценариев

**Преимущества**:

- Гибкость: поддержка сложных ветвлений и циклов
- Визуализация: соответствует визуальному редактору
- Расширяемость: легко добавлять новые типы узлов
- Валидация: можно проверять корректность графа

### 7.7. Взаимодействие Frontend ↔ Backend

**Типичный поток данных**:

```
┌─────────────┐                    ┌─────────────┐
│  Frontend   │                    │   Backend   │
│   (React)   │                    │   (API)     │
└──────┬──────┘                    └──────┬──────┘
       │                                  │
       │  1. GET /api/v1/bots/           │
       │─────────────────────────────────>│
       │                                  │
       │  2. [JWT Token в Header]        │
       │                                  │
       │                                  │ 3. Валидация токена
       │                                  │ 4. Запрос к БД
       │                                  │
       │  5. JSON Response                │
       │<─────────────────────────────────│
       │                                  │
       │  6. PUT /api/v1/bots/:id/       │
       │     { status: "active" }        │
       │─────────────────────────────────>│
       │                                  │
       │                                  │ 7. Обновление в БД
       │                                  │ 8. Обновление Telegram
       │                                  │
       │  9. Success Response             │
       │<─────────────────────────────────│
       │                                  │
```

### 7.8. Масштабируемость бэкенда

#### 7.8.1. Горизонтальное масштабирование

- **Load Balancer**: Распределение нагрузки между несколькими серверами
- **Stateless Design**: JWT позволяет использовать любой сервер
- **Database Replication**: Репликация БД для чтения

#### 7.8.2. Оптимизация производительности

- **Кэширование**: Redis для кэширования часто запрашиваемых данных
- **Асинхронная обработка**: Очереди задач для тяжелых операций
- **Индексация БД**: Оптимизация запросов через индексы

#### 7.8.3. Мониторинг и логирование

- **Логирование**: Централизованное логирование всех операций
- **Метрики**: Мониторинг производительности и ошибок
- **Алерты**: Уведомления о критических ошибках

## 8. Обоснование архитектурных решений

### 8.1. Выбор React

**Преимущества**:

- Компонентная архитектура соответствует структуре UI
- Большое сообщество и экосистема
- Виртуальный DOM обеспечивает производительность
- React Hooks упрощают управление состоянием

### 8.2. Выбор Vite

**Преимущества**:

- Быстрая сборка и Hot Module Replacement (HMR)
- Нативная поддержка ES-модулей
- Оптимизация для разработки и продакшена

### 8.3. Выбор ReactFlow

**Обоснование**:

- Специализированная библиотека для визуальных редакторов
- Встроенная поддержка drag-and-drop
- Гибкая система кастомизации узлов
- Оптимизированная производительность для больших графов

### 8.4. CSS Modules вместо других решений

**Обоснование**:

- Простота использования (без дополнительных зависимостей)
- Изоляция стилей без накладных расходов
- Совместимость с существующим CSS-кодом
- Не требует компиляции (в отличие от SASS/LESS)

## 9. Паттерны проектирования

### 9.1. Композиция компонентов

Компоненты строятся через композицию, а не наследование:

```jsx
<App>
  <NavPanel />
  <Routes>
    <Route element={<Dashboard />} />
  </Routes>
</App>
```

### 9.2. Контролируемые компоненты

Формы и инпуты используют паттерн контролируемых компонентов:

```jsx
<input value={name} onChange={(e) => setName(e.target.value)} />
```

### 9.3. Callback Pattern

Передача функций обратного вызова для синхронизации состояния:

```jsx
data: {
  onChange: handleNodeChange;
}
```

### 9.4. Factory Pattern

Генерация уникальных идентификаторов для узлов:

```javascript
const generateNodeId = (type, existingNodes) => {
  // Логика генерации ID
};
```

## 10. Масштабируемость и расширяемость

### 10.1. Добавление новых типов узлов

Для добавления нового типа узла необходимо:

1. Создать компонент в `Nodes/`
2. Добавить тип в `nodeTypes` в `ScriptEdit.jsx`
3. Добавить логику создания в `onAddNode`

### 10.2. Расширение функциональности

Архитектура позволяет легко:

- Добавлять новые страницы через роутинг
- Расширять API-интеграцию через Axios
- Добавлять новые компоненты без изменения существующих

## 11. Заключение

Архитектура приложения построена на принципах:

- **Модульности**: Каждый компонент имеет четкую ответственность
- **Переиспользования**: Компоненты могут использоваться в разных контекстах
- **Расширяемости**: Легко добавлять новые функции
- **Поддерживаемости**: Код организован логично и понятно

Выбранные технологии и паттерны обеспечивают баланс между производительностью разработки, качеством кода и возможностями масштабирования приложения.
